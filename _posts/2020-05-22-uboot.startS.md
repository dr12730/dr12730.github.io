---
title: uboot源码分析-启动第一阶段
date: 2020-05-22 20:31:39 +0800
key: 2020-05-22-uboot.startS
cover: /assets/images/posts/2020-05-22-uboot.startS/cover.jpg
mode: immersive
header:
  theme: dark
article_header:
  type: overlay
  theme: dark
  background_color: '#203028'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(34, 139, 87 , .4), rgba(139, 34, 139, .4))'
    src: /assets/images/posts/2020-05-22-uboot.startS/header_image.jpg
mathjax: true
mathjax_autoNumber: false
mermaid: false
chart: false
tags: 
---

*本文主要分析 uboot 源码的 start.S 文件*

<!--more-->

# uboot源码分析-启动第一阶段

## start.S引入

### u-boot.lds中找到start.S入口

- C语言中整个项目的入口就是main函数（这是C语言规定的），所以譬如说一个有10000个.c文件的项目，第一个要分析的文件就是包含了main函数的那个文件。
- 在uboot中因为有汇编阶段参与，因此不能直接找 main.c。整个程序的入口取决于链接脚本中ENTRY声明的地方。`ENTRY(_start)` 因此 `_start` 符号所在的文件就是整个程序的起始文件，`_start` 所在处的代码就是整个程序的起始代码。

## start.S解析

### 不简单的头文件包含


```js
#include <config.h> // 就是 include/configs/x210_sd.h 文件
// version.h 就是 include/version_autogenerated.h
#include <version.h>
#if defined(CONFIG_ENABLE_MMU)
#include <asm/proc/domain.h>
#endif
#include <regs.h>

#ifndef CONFIG_ENABLE_MMU
#ifndef CFG_PHY_UBOOT_BASE
#define CFG_PHY_UBOOT_BASE	CFG_UBOOT_BASE
#endif
#endif
```

- config.h是在include目录下的，这个文件不是源码中本身存在的文件，而是配置过程中自动生成的文件。（详见mkconfig脚本）。这个文件的内容其实是包含了一个头文件：`#include <configs/x210_sd.h>`
- 经过分析后，发现start.S中包含的第一个头文件就是：`include/configs/x210_sd.h`，这个文件是整个uboot移植时的配置文件。这里面是好多宏。因此这个头文件包含将 `include/configs/x210_sd.h` 文件和 `start.S` 文件关联了起来。因此之后在分析 `start.S` 文件时，主要要考虑的就是 `x210_sd.h` 文件。
- `#include <version.h>`。`include/version.h` 中包含了 `include/version_autogenerated.h`，这个头文件就是配置过程中自动生成的。里面就一行内容：#define U_BOOT_VERSION "U-Boot 1.3.4"。这里面定义的宏U_BOOT_VERSION的值是一个字符串，字符串中的版本号信息来自于Makefile中的配置值。这个宏在程序中会被调用，在uboot启动过程中会串口打印出uboot的版本号，那个版本号信息就是从这来的。
- `#include <asm/proc/domain.h>`。asm目录不是uboot中的原生目录，uboot中本来是没有这个目录的。asm目录是配置时创建的一个符号链接，实际指向的是就是asm-arm（详解上一章节分析mkconfig脚本时）经过分析后发现，实际文件是：`include/asm-arm/proc-armv/domain.h`
- 从这里可以看出之前配置时创建的符号链接的作用，如果没有这些符号链接则编译时根本通不过，因为找不到头文件。（所以uboot不能在windows的共享文件夹下配置编译，因为windows中没有符号链接）

### 启动代码的16字节头部

```js
#if defined(CONFIG_EVT1) && !defined(CONFIG_FUSED)
	.word 0x2000
	.word 0x0
	.word 0x0
	.word 0x0
#endif
```

1. 在SD卡启动/Nand启动等整个镜像开头需要16字节的校验头。（mkv210image.c中就是为了计算这个校验头）。我们以前做裸机程序时根本没考虑这16字节校验头，因为：1、如果我们是usb启动直接下载的方式启动的则不需要16字节校验头（irom application note）；2、如果是SD卡启动mkv210image.c中会给原镜像前加16字节的校验头。
2. uboot这里start.S中在开头位置放了16字节的填充占位，这个占位的16字节只是保证正式的image的头部确实有16字节，但是这16字节的内容是不对的，还是需要后面去计算校验和然后重新填充。

### 异常向量表的构建

```js
.globl _start
_start: b	reset
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq

_undefined_instruction:
	.word undefined_instruction
// 省略 ....
.global _end_vect
_end_vect:
	.balignl 16,0xdeadbeef // 地址对齐
        
_TEXT_BASE:
	.word	TEXT_BASE
```

1. 异常向量表是硬件决定的，软件只是参照硬件的设计来实现它。

2. 异常向量表中每种异常都应该被处理，否则真遇到了这种异常就跑飞了。但是我们在uboot中并未非常细致的处理各种异常。

3. 复位异常处的代码是：`b reset`，因此在CPU复位后真正去执行的有效代码是reset处的代码，因此reset符号处才是真正的有意义的代码开始的地方。

   ```js
   reset:
    // set the cpu to SVC32 mode and IRQ & FIQ disable
    msr cpsr_c, #0xd3 @ I & F disable, Mode: 0x13 - SVC
   ```

   - `msr	cpsr_c, #0xd3`	将CPU设置为禁止 `FIQ IRQ`，`ARM` 状态，`SVC` 模式。
   - 其实ARM CPU在复位时默认就会进入SVC模式，但是这里还是使用软件将其置为SVC模式。整个uboot工作时CPU一直处于SVC模式。

4. `.balignl 16,0xdeadbeef`.	这一句指令是让当前地址对齐排布，如果当前地址不对齐则自动向后走地址直到对齐，并且向后走的那些内存要用 `0xdeadbeef` 来填充。

   - `0xdeadbeef` 这是一个十六进制的数字，这个数字很有意思，组成这个数字的十六进制数全是 `abcdef` 之中的字母，而且这8个字母刚好组成了英文的 dead beef 这两个单词，字面意思是坏牛肉。
   - 为什么要对齐访问？有时候是效率的要求，有时候是硬件的特殊要求。

5. `TEXT_BASE` 就是我们链接时指定的uboot的链接地址。（值就是c3e00000）

   > 源代码中和配置Makefile中很多变量是可以互相运送的。简单来说有些符号的值可以从Makefile中传递到源代码中

### DDR 的物理地址

```js
/*
 * Below variable is very important because we use MMU in U-Boot.
 * Without it, we cannot run code correctly before MMU is ON.
 * by scsuh.
 */
_TEXT_PHY_BASE:
	.word	CFG_PHY_UBOOT_BASE

.globl _armboot_start
_armboot_start:
	.word _start
```

1. `CFG_PHY_UBOOT_BASE` uboot在DDR中的物理地址

   ```js
   #define CFG_UBOOT_BASE		0x33e00000  /*yan*/
   ```

### 识别并暂存启动介质选择

```js
/* Read booting information */
ldr	r0, =PRO_ID_BASE
ldr	r1, [r0,#OMR_OFFSET]
bic	r2, r1, #0xffffffc1
```

1. 从哪里启动是由SoC的 `OM5:OM0` 这6个引脚的高低电平决定的。

2. 实际上在210内部有一个寄存器（地址是 `0xE0000004`），这个寄存器中的值是硬件根据OM引脚的设置而自动设置值的。这个值反映的就是OM引脚的接法（电平高低），也就是真正的启动介质是谁。

3. 我们代码中可以通过读取这个寄存器的值然后判断其值来确定当前选中的启动介质是Nand还是SD还是其他的。

4. start.S的225-227行执行完后，在r2寄存器中存储了一个数字，这个数字等于某个特定值时就表示SD启动，等于另一个特定值时表示从Nand启动····

5. 260行中给r3中赋值 `#BOOT_MMCSD(0x03)`，这个在SD启动时实际会被执行，因此执行完这一段代码后r3中存储了0x03，以后备用。

   ```js
   /* SD/MMC BOOT */
   cmp     r2, #0xc
   moveq   r3, #BOOT_MMCSD	
   ```

### 设置栈（SRAM中的栈）并调用lowlevel_init

```js
// Go setup Memory and board specific bits prior to relocation.
// 要调用函数就要指定栈，在函数中可能还会有函数调用
ldr	sp, =0xd0036000 /* end of sram dedicated to u-boot */
sub	sp, sp, #12	/* set stack */
mov	fp, #0

bl	lowlevel_init	/* go setup pll,mux,memory */
```

1. 284-286行第一次设置栈。这次设置栈是在SRAM中设置的，因为当前整个代码还在SRAM中运行，此时DDR还未被初始化还不能用。栈地址 `0xd0036000` 是自己指定的，指定的原则就是这块空间只给栈用，不会被别人占用。

   ![内存地址分配](/assets/images/posts/2020-05-22-uboot.startS/mm.jpg)

2. 在调用函数前初始化栈，主要原因是在被调用的函数内还有再次调用函数，而BL只会将返回地址存储到LR中，但是我们只有一个LR，所以在第二层调用函数前要先将LR入栈，否则函数返回时第一层的返回地址就丢了。

## lowlevel_init.S

### 检查复位状态

```js
push	{lr}
/* check reset status  */
ldr	r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)
ldr	r1, [r0]
bic	r1, r1, #0xfff6ffff
cmp	r1, #0x10000 // 第17位
beq	wakeup_reset_pre
cmp	r1, #0x80000 // 第19位
beq	wakeup_reset_from_didl
```

1. 复杂CPU允许多种复位情况。譬如直接冷上电、热启动、睡眠(低功耗)状态下的唤醒等，这些情况都属于复位。所以我们在复位代码中要去检测复位状态，来判断到底是哪种情况。

   - ` ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET = 0xE010_A000`

   - s5pv210 数据手册说明

     ![复位控制器](/assets/images/posts/2020-05-22-uboot.startS/reset.jpg)

2. 判断哪种复位的意义在于：

   - 冷上电时DDR是需要初始化才能用的
   - 热启动或者低功耗状态下的复位则不需要再次初始化DDR。

### 其他设置

```js
/* IO Retention release */
/* Disable Watchdog */
/* SRAM(2MB) init for SMDKC110 */
/* GPJ4 SROM_ADDR_16to21 */
/* CS0 - 16bit sram, enable nBE, Byte base address */
/* PS_HOLD pin(GPH0_0) set to high */
// 开发板供电锁存
ldr	r0, =(ELFIN_CLOCK_POWER_BASE + PS_HOLD_CONTROL_OFFSET)
ldr	r1, [r0]
orr	r1, r1, #0x300	
orr	r1, r1, #0x1	
str	r1, [r0]
```

- `ELFIN_CLOCK_POWER_BASE + PS_HOLD_CONTROL_OFFSET = 0xE010_E000`

- s5pv210 数据手册说明

  MISC Register (OTHERS, R/W, Address = 0xE010_E000)

  | OTHERS         | Bit     | 说明                                                         | 初始值 |
  | -------------- | ------- | ------------------------------------------------------------ | ------ |
  | 保留           | [31:12] | 保留                                                         | 0x5    |
  | 保留           | [11:10] | 保留                                                         | 0x0    |
  | DIR            | [9]     | 方向（0：输入；1：输出）                                     | 1      |
  | DATA           | [8]     | 驱动值（0：低；1：高）                                       | 0      |
  | 保留           | [7:1]   | 保留                                                         | 0x0    |
  | PS_HOLD_OUT_EN | [0]     | XEINT[0] 引脚由该寄存器值控制，当该字段为'1'时，GPIO 章的 XEINT[0] 控制寄存器的值被忽略，也就是不做GPIO引脚使用。(0：禁用，1：启用) | 0      |

  > PS_HOLD(与XEINT[0]复用)引脚的值在任何电源模式下都会保持不变。该寄存器处于存活区域，仅通过XnRESET或断电复位。

  

### 判断当前代码执行位置

```js
/* 当我们已经在RAM中运行的时候，我们不需要重新配置U-Boot。
 * 实际上，在U-Boot运行在RAM中之前，内存控制器必须先配置好。*/
ldr	r0, =0xff000fff
bic	r1, pc, r0		/* r0 <- current base addr of code */
ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
bic	r2, r2, r0		/* r0 <- current base addr of code */
cmp     r1, r2                  /* compare r0, r1                  */
beq     1f			/* r0 == r1 then skip sdram init   */
```

1. `lowlevel_init.S` 的110-115行。
2. 判定当前代码执行的位置在SRAM中还是在DDR中。为什么要做这个判定？原因
   - BL1（uboot的前一部分）在SRAM中有一份，在DDR中也有一份，因此如果是冷启动那么当前代码应该是在SRAM中运行的BL1，如果是低功耗状态的复位这时候应该就是在DDR中运行的。
   - 我们判定当前运行代码的地址是有用的，可以指导后面代码的运行。
     - 譬如在lowlevel_init.S中判定当前代码的运行地址，就是为了确定要不要执行时钟初始化和初始化DDR的代码。
     - 如果当前代码是在SRAM中，说明冷启动，那么时钟和DDR都需要初始化；
     - 如果当前代码是在DDR中，那么说明是热启动则时钟和DDR都不用再次初始化。
3. `bic r1, pc, r0`	这句代码的意义是：将pc的值中的某些bit位清0，剩下一些特殊的bit位赋值给r1（r0中为1的那些位清零）相等于：`r1 = pc & ~(ff000fff)`，取出 PC 中的高位
4. `ldr r2, _TEXT_BASE`	加载链接地址到r2，然后将r2的相应位清0剩下特定位 `bic	r2, r2, r0`，取出链接地址的高位放到 r2 中
5. 最后比较r1和r2.

这一段代码是通过读取当前运行地址和链接地址，然后处理两个地址后对比是否相等，来判定当前运行是在SRAM中（不相等）还是DDR中（相等）。从而决定是否跳过下面的时钟和DDR初始化。

### 内存、时钟、串口初始化

```js
bl system_clock_init
/* Memory initialize */
bl mem_ctrl_asm_init

1:
	/* for UART */
	bl uart_asm_init
	bl tzpc_init
```

1. `system_clock_init`，这个初始化时钟的过程和裸机中初始化的过程一样的，只是更加完整而且是用汇编代码写的。

2. 在`x210_sd.h` 中300行到428行，都是和时钟相关的配置值。这些宏定义就决定了210的时钟配置是多少。也就是说代码在 `lowlevel_init.S` 中都写好了，但是代码的设置值都被宏定义在 `x210_sd.h` 中了。因此，如果移植时需要更改CPU的时钟设置，根本不需要动代码，只需要在 `x210_sd.h` 中更改配置值即可。

   ```js
   system_clock_init:
   	ldr	r0, =ELFIN_CLOCK_POWER_BASE	@0xe0100000
   	/* Set Mux to FIN */
   	ldr	r1, =0x0
   	str	r1, [r0, #CLK_SRC0_OFFSET] 
   	ldr	r1,	=APLL_LOCKTIME_VAL // 在x210_sd.h中定义
   	str	r1,	[r0, #APLL_LOCK_OFFSET]
   ```

3. `mem_ctrl_asm_init`，初始化DDR。

   - 该函数和裸机中初始化DDR代码是一样的。实际上裸机中初始化DDR的代码就是从这里抄的。
   - 配置值中有一个和裸机中讲的不一样。`DMC0_MEMCONFIG_0`，在裸机中配置值为 `0x20E01323`；在uboot中配置为 `0x30F01313`.这个配置不同就导致结果不同。
     - 在裸机中DMC0的256MB内存地址范围是`0x20000000-0x2FFFFFFF`
     - 在uboot中DMC0的256MB内存地址范围为 `0x30000000-0x3FFFFFFF`
   - 之前在裸机中时配置为2开头的地址，当时并没有说可以配置为3开头。从分析九鼎移植的uboot可以看出：DMC0上允许的地址范围是 `20000000-3FFFFFFF`（一共是512MB），而我们实际只接了256MB物理内存，SoC允许我们给这256MB挑选地址范围。
   - 总结一下：在uboot中，可用的物理地址范围为：0x30000000-0x4FFFFFFF。一共512MB，其中30000000-3FFFFFFF为DMC0，40000000-4FFFFFFF为DMC1。
   - 我们需要的内存配置值在`x210_sd.h`的438行到468行之间。分析的时候要注意条件编译的条件，配置头文件中考虑了不同时钟配置下的内存配置值，这个的主要目的是让不同时钟需求的客户都能找到合适自己的内存配置值。

4. `uart_asm_init`，初始化串口，初始化完了后通过串口发送了一个'O'

5. `tzpc_init` ，trust zone初始化

6. `pop {pc}` 以返回，返回前通过串口打印'K'

`lowlevel_init.S` 执行完如果没错那么就会串口打印出"OK"字样。这应该是我们uboot中看到的最早的输出信息。

### 检查复位状态

```js
	ldr	r0, =(ELFIN_CLOCK_POWER_BASE+RST_STAT_OFFSET)
	ldr	r1, [r0]
	bic	r1, r1, #0xfffeffff
	cmp	r1, #0x10000
	beq	wakeup_reset_pre
	/* ABB disable */
	ldr	r0, =0xE010C300
	orr	r1, r1, #(0x1<<23)
	str	r1, [r0]
	/* Print 'K' */
	ldr	r0, =ELFIN_UART_CONSOLE_BASE
	ldr	r1, =0x4b4b4b4b
	str	r1, [r0, #UTXH_OFFSET]

	pop	{pc}
```

1. r0 指向复位状态寄存器

   ![复位状态寄存器](/assets/images/posts/2020-05-22-uboot.startS/reset.png)

2. 判断第16位：是否通过SLEEP模式唤醒复位

   - 是：进行一系列初始化
   - 否：继续，并打印 K 结束

## system_clock_init 时钟初始化分析

### 设置 A/MPLL 时钟源和锁定时间

```js
system_clock_init:
	ldr	r0, =ELFIN_CLOCK_POWER_BASE	@0xe0100000
	/* Set Mux to FIN */
	ldr	r1, =0x0
	str	r1, [r0, #CLK_SRC0_OFFSET] @0x200
	ldr	r1,	=APLL_LOCKTIME_VAL @0xe10
	str	r1,	[r0, #APLL_LOCK_OFFSET] @0x0
	/********lxg added*********************/
	ldr	r0, =ELFIN_CLOCK_POWER_BASE	@0xe0100000
	ldr	r1,	=MPLL_LOCKTIME_VAL @0xe10
	str	r1,	[r0, #MPLL_LOCK_OFFSET] @ 0x8
	/********end*********************/
```

1. `ELFIN_CLOCK_POWER_BASE = 0xe0100000`

   由 S5PV210 数据手册可以找到寄存器映射表

   | 寄存器    | 地址        | R/W  | 说明                    | 初始值      |
   | --------- | ----------- | ---- | ----------------------- | ----------- |
   | APLL_LOCK | 0xE010_0000 | R/W  | 用于APLL的控制PLL锁定期 | 0x0000_0FFF |
   | 保留      | 0xE010_0004 | -    | 保留                    | -           |

2. 选择 FIN

   ![选择时钟源](/assets/images/posts/2020-05-22-uboot.startS/pll_fin.jpg)

   在 $MUX_{APLL}$ 开关处，选择 $FIN_{PLL}$ 而不是 $FOUT_{APLL}$，这里的 $FIN_{APLL} = 24MHz$

   - 时钟源 0 地址 `CLK_SRC0_OFFSET = 0x200`

     | 寄存器   | 地址        | R/W  | 说明                    | 初始值      |
     | -------- | ----------- | ---- | ----------------------- | ----------- |
     | CLK_SRC0 | 0xE010_0200 | R/W  | 选择时钟源0（主时钟源） | 0x0000_0000 |

   - 时钟源0寄存器功能

     ![时钟源0寄存器](/assets/images/posts/2020-05-22-uboot.startS/clk_src0.jpg)

     - `APLL_SEL = FINPLL`
     - `MPLL_SEL = FINPLL`

3. 设定 PLL 稳定时间

   - PLL 需要一段时间锁定，之后才能输出稳定的时钟信号

   - `A/MPLL_LOCK_OFFSET = 0xe10`

     | A/M/VPLL_LOCK | Bit     | 说明                                                         | 初始值 |
     | ------------- | ------- | ------------------------------------------------------------ | ------ |
     | 保留          | [31:16] | 保留                                                         | 0x0000 |
     | PLL_LOCKTIME  | [15:0]  | 产生稳定时钟输出所需的周期，该计数基于PLL的源时钟。  <br />- 用于APLL、MPLL、EPLL的FINPLL  <br />- 用于VPLL的FINVPLL | 0x0    |

### 设置 A/M/EPLL 的时钟输出频率

```js
#define CLK_DIV0_MASK	0x7fffffff
#define CLK_DIV0_OFFSET	0x300
#define set_pll(mdiv, pdiv, sdiv)	(1<<31 | mdiv<<16 | pdiv<<8 | sdiv)
#define APLL_VAL	set_pll(APLL_MDIV,APLL_PDIV,APLL_SDIV)
#define CLK_DIV0_VAL ((0<<APLL_RATIO)|(4<<A2M_RATIO)|(4<<HCLK_MSYS_RATIO)\
        |(1<<PCLK_MSYS_RATIO) | (3<<HCLK_DSYS_RATIO)|(1<<PCLK_DSYS_RATIO)\
        |(4<<HCLK_PSYS_RATIO)|(1<<PCLK_PSYS_RATIO))

# 关闭 PLL
ldr	r1, =0x0
str	r1, [r0, #APLL_CON0_OFFSET]
ldr	r1, =0x0
str	r1, [r0, #MPLL_CON_OFFSET]
# 设置分频系数
ldr   	r1, [r0, #CLK_DIV0_OFFSET] @0x300
ldr	r2, =CLK_DIV0_MASK  @0x7fffffff
bic	r1, r1, r2

ldr	r2, =CLK_DIV0_VAL
orr	r1, r1, r2
str	r1, [r0, #CLK_DIV0_OFFSET]

ldr	r1, =APLL_VAL
str	r1, [r0, #APLL_CON0_OFFSET]

ldr	r1, =MPLL_VAL
str	r1, [r0, #MPLL_CON_OFFSET]

ldr	r1, =VPLL_VAL
str	r1, [r0, #VPLL_CON_OFFSET]
```

1. 关闭 A/MPLL

   - 在设置 PLL 之前要关闭 PLL

   - `APLL_CON0` 功能

     ![APLL_CON0功能](/assets/images/posts/2020-05-22-uboot.startS/apll_con0.jpg)

2. 时钟分频 `CLK_DIV0_VAL`

   - 寄存器功能

     ![时钟分频寄存器](/assets/images/posts/2020-05-22-uboot.startS/clk_div0.jpg)

   - 清除 `CLK_DIV0_OFFSET` 寄存器

   - 设置 `CLK_DIV0_OFFSET` 寄存器

     | 分频系数        | 说明4                                         | 设置值 | 结果 |
     | --------------- | --------------------------------------------- | ------ | ---- |
     | PCLK_PSYS_RATIO | PCLK_PSYS = HCLK_PSYS / (PCLK_PSYS_RATIO + 1) | 1      | 66MHz |
     | HCLK_PSYS_RATIO | HCLK_PSYS = MOUT_PSYS / (HCLK_PSYS_RATIO + 1) | 4      | 133MHz |
     | PCLK_DSYS_RATIO | PCLK_DSYS = HCLK_DSYS / (PCLK_DSYS_RATIO + 1) | 1      | 83MHz |
     | HCLK_DSYS_RATIO | HCLK_DSYS = MOUT_DSYS / (HCLK_DSYS_RATIO + 1) | 3      | 166MHz |
     | PCLK_MSYS_RATIO | PCLK_MSYS = HCLK_MSYS / (PCLK_MSYS_RATIO + 1) | 1      | 100MHz  |
     | HCLK_MSYS_RATIO | HCLK_MSYS = ARMCLK / (HCLK_MSYS_RATIO + 1)    | 4      | 200MHz |
     | A2M_RATIO       | SCLKA2M = SCLKAPLL / (A2M_RATIO + 1)          | 4      | 200MHz |
     | APLL_RATIO      | ARMCLK = MOUT_MSYS / (APLL_RATIO + 1)         | 0      | 1GHz |

3. 设置 APLL 的输出频率

   - `APLL_CON0_OFFSET` 功能

     ![APLL配置寄存器0](/assets/images/posts/2020-05-22-uboot.startS/apll_con0.jpg)

   - `APLL_VAL` 的值

     这些值来自三星官方的推荐

     ![APLL 推荐值](/assets/images/posts/2020-05-22-uboot.startS/apll_rec.jpg)

     ```js
     #define APLL_MDIV       0x7d = 125
     #define APLL_PDIV       0x3
     #define APLL_SDIV       0x1
     
     #define set_pll(mdiv, pdiv, sdiv)	(1<<31 | mdiv<<16 | pdiv<<8 | sdiv)
     #define APLL_VAL	set_pll(APLL_MDIV,APLL_PDIV,APLL_SDIV)
     
     @ APLL_VAL = (1<<31 | 0x7d<<16 | 0x3<<8 | 0x1)
     ```

   - APLL 输出频率计算公式

     $$F_{OUT} = \dfrac{M_{DIV} \times F_{IN}}{P_{DIV} \times 2^{S_{DIV} -1}} = \dfrac{125 \times 24}{3 \times 2^0} = 1000 MHz$$

4. 设置 MPLL 的输出频率

   1. `MPLL_CON0_OFFSET` 功能

      ![MPLL配置寄存器](/assets/images/posts/2020-05-22-uboot.startS/mpll_con.jpg)

   2. `MPLL_VAL` 的值

      ![MPLL 推荐](/assets/images/posts/2020-05-22-uboot.startS/mpll_rec.jpg)

      ```js
      #define MPLL_MDIV	0x29b  = 667
      #define MPLL_PDIV	0xc    = 12
      #define MPLL_SDIV	0x1
      
      @MPLL_VAL = (1<<31 | 0x29b<<16 | 0xc <<8 | 0x1)
      ```

   3. MPLL 输出频率

      $$F_{OUT} = \dfrac{M_{DIV} \times F_{IN}}{P_{DIV} \times 2^{S_{DIV}}} = \dfrac{667 \times 24}{12 \times 2^1} = 667 MHz$$

   4. EPLL 的输出频率计算方法与上同

### 设置 A/M/EPLL 的时钟分频系数

```js
ldr r1, [r0, #CLK_DIV1_OFFSET]
ldr	r2, =CLK_DIV1_MASK
bic	r1, r1, r2

ldr	r2, =CLK_DIV1_VAL
orr	r1, r1, r2
str	r1, [r0, #CLK_DIV1_OFFSET]

ldr	r2, =CLK_DIV2_VAL
orr	r1, r1, r2
str	r1, [r0, #CLK_DIV2_OFFSET]

ldr	r2, =CLK_DIV4_VAL
orr	r1, r1, r2
str	r1, [r0, #CLK_DIV4_OFFSET]

ldr	r2, =CLK_DIV6_VAL
orr	r1, r1, r2
str	r1, [r0, #CLK_DIV6_OFFSET]
```

1. 设置 `CLK_DIV1`

   1. 寄存器功能

      ![CLK_DIV功能](/assets/images/posts/2020-05-22-uboot.startS/clk_div1.png)

   2. 设置值 `CLK_DIV_VAL`

      ```js
      #define CLK_DIV1_VAL	((1<<16)|(1<<12)|(1<<8)|(1<<4))
      ```

2. 设置 `DLK_DVI2`

   1. 寄存器

      ![CLK_DIV2功能](/assets/images/posts/2020-05-22-uboot.startS/clk_div2.png)

   2. 设置值

      ```js
      #define CLK_DIV2_VAL	(1<<0)
      ```

3. 设置 `CLK_DIV4`

   1. 寄存器

      ![CLK_DIV4功能](/assets/images/posts/2020-05-22-uboot.startS/clk_div4.png)

   2. 设置值

      ```js
      #define CLK_DIV4_VAL	0x99990000
      ```

4. 设置 `CLK_div6`

   1. 寄存器

      ![CLK_DIV6功能](/assets/images/posts/2020-05-22-uboot.startS/clk_div6.png)

   2. 设置值

      ```js
      #define CLK_DIV6_VAL	0x71000
      ```

### 打开 APLL 的 AFC 功能

```js
#define AFC_ON		0x00000000

#if defined(CONFIG_EVT1) @在 autoconfig.mk 中定义
	ldr	r1, =AFC_ON
	str	r1, [r0, #APLL_CON1_OFFSET]
#endif
```

| 寄存器    | 地址        | R/W  | 说明                            | 初始值      |
| --------- | ----------- | ---- | ------------------------------- | ----------- |
| APLL_CON1 | 0xE010_0104 | R/W  | 控制PLL-AFC（自适应频率校准器） | 0x0000_0000 |

| APLL_CON1 | Bit   | 说明                                                         | 初始值 |
| --------- | ----- | ------------------------------------------------------------ | ------ |
| AFC_ENB   | [31]  | 决定是否启用AFC。0 : 启用；1 : 停用<br/>AFC在宽范围、高相位噪声(或抖动)和快速锁定时间的情况下选择VCO的自适应频率曲线。<br/>用户应参考3.3.1关于是否在给定的P/M/S值下使用AFC。 | 0x0000 |
| AFC       | [4:0] | AFC值。如果用户禁用AFC，该值应手动设置                       | 0x0    |

### 检察 MPLL 是否锁定

```js
#if defined(CONFIG_CHECK_MPLL_LOCK)
	/* MPLL software workaround */
	ldr	r1, [r0, #MPLL_CON_OFFSET]
	orr     r1, r1, #(1<<28)
	str	r1, [r0, #MPLL_CON_OFFSET]

	mov	r1, #0x100
1:	subs	r1, r1, #1
	bne	1b

	ldr	r1, [r0, #MPLL_CON_OFFSET]
	and	r1, r1, #(1<<29)
	cmp	r1, #(1<<29)
	bne 	retryloop

	/* H/W lock detect disable */
	ldr	r1, [r0, #MPLL_CON_OFFSET]
	bic     r1, r1, #(1<<28)
	str	r1, [r0, #MPLL_CON_OFFSET]
#endif
```

1. 先使能 H/W 锁定探测 `MPLL_CON_OFFSET |= (1<<28)`

   这一位在 S5PV210 数据手册中是保留位，有可能是三星没有写出来，也有可能是为了兼容其他板子

2. 延时 `0x100`，再检查 `(1<<29)` 是不是锁定

   ![MPLL配置寄存器](/assets/images/posts/2020-05-22-uboot.startS/mpll_con.png)

### 再次选择时钟源

```js
ldr	r1, [r0, #CLK_SRC0_OFFSET]
ldr	r2, =0x00000111
orr	r1, r1, r2
str	r1, [r0, #CLK_SRC0_OFFSET]

// added by terry 2012.12.4 for camera 
ldr r1, [r0, #CLK_SRC1_OFFSET]
bic r1, r1, #(0xf<<12)
orr r1, r1, #(0x1<<12) //0001 XusbXTI
str r1, [r0, #CLK_SRC1_OFFSET]

mov	pc, lr @ 时钟配置完成，函数返回
```

1. `CLK_SRC0_OFFSET `设置 A/M/EPLL 时钟源

   ![时钟源0寄存器](/assets/images/posts/2020-05-22-uboot.startS/clk_src0.jpg)

   把 A/M/EPLL 的时钟源都选择为 $F_{OUT}$

   ![](/assets/images/posts/2020-05-22-uboot.startS/pll_fin.jpg)

2. `CLK_SRC1_OFFSET` 设置摄像头0时钟源

   | CLK_SRC1 | Bit     | 说明                                                         | 初始值 |
   | -------- | ------- | ------------------------------------------------------------ | ------ |
   | CAM0_SEL | [15:12] | 控制MUXCAM0，它是CAM0的源时钟（0000:XXTI，0001:XusbXTI，0010:SCLK到HDMI27M，0011:SCLK到USBPHY0，0100:SCLK到USBPHY1，010101:SCLK到HDMIPHY，0110:SCLKMPLL，**0111:SCLKEPLL**，1000:SCLKVPLL，其他：保留） | 0x0    |

## mem_ctrl_asm_init 内存初始化分析

### 设置 DMC0/1 驱动强度

```js
/* DMC0 Drive Strength (Setting 2X) */
@ DRAM memory controllers (DMC0 and DMC1)
ldr	r0, =ELFIN_GPIO_BASE
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_0DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_1DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_2DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_3DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_4DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_5DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_6DRV_SR_OFFSET]
ldr	r1, =0x0000AAAA
str	r1, [r0, #MP1_7DRV_SR_OFFSET]
ldr	r1, =0x00002AAA
str	r1, [r0, #MP1_8DRV_SR_OFFSET]
/* DMC1 设置与上同 */
```

1. `ELFIN_GPIO_BASE = 0xE020_0000`

   ![特殊功能寄存器映射](/assets/images/posts/2020-05-22-uboot.startS/sfrm.png)

2. GPIO 驱动能力设置寄存器

   设置 MP1 各引脚驱动能力为 2x

   | MP1_0DRV    | Bit                 | 说明                                        | 初始值 |
   | ----------- | ------------------- | ------------------------------------------- | ------ |
   | MP1_0DRV[n] | [2n+1:2n]<br/>n=0~7 | 00 = 1x<br/>10 = 2x<br/>01 = 3x<br/>11 = 4x | 0xAAAA |

3. 核心板原理图

   ![核心板内存](/assets/images/posts/2020-05-22-uboot.startS/ddr1.png)

4. S5PV210 数据手册

   | 引脚名称                  | GPIO                                           |
   | ------------------------- | ---------------------------------------------- |
   | Xm0ADDR[0:15]             | MP0_4[0:7], MP0_5[0:7]                         |
   | Xm0DATA[0:15]             | MP0_6[0:7], MP0_7[0:7]                         |
   | Xm1ADDR[0:15]             | MP1_0[0:7], MP1_1[0:7]                         |
   | Xm1DATA[0:31]             | MP1_2[0:7], MP1_3[0:7], MP1_4[0:7], MP1_5[0:7] |
   | Xm1DQS[0:3], Xm1DQSn[0:3] | MP1_6[0:7]                                     |
   | Xm1DQM[0:3]               | MP1_7[0:3]                                     |
   | Xm1CKE[0:1]               | MP1_7[4:5]                                     |
   | Xm1SCLK,  Xm1nSCLK        | MP1_7[6:7]                                     |
   | Xm1CSn[0:1]               | MP1_8[0:1]                                     |
   | Xm1RASn                   | MP1_8[2]                                       |

   Xm2ADDR[0] 与上同

### DMC0 初始化

```js
/* DMC0 initialization at single Type*/
ldr	r0, =APB_DMC_0_BASE @ 0xF000_0000

@PhyControl0 DLL parameter setting, manual 0x00101000
ldr	r1, =0x00101000 @ (0x10<<16 | 0x10<<8)
str	r1, [r0, #DMC_PHYCONTROL0]
@PhyControl1 DLL parameter setting, LPDDR/LPDDR2 Case
ldr	r1, =0x00000086  @ (0x8<<4 | 0x6<<0)
str	r1, [r0, #DMC_PHYCONTROL1]

ldr	r1, =0x00101002  @PhyControl0 DLL on
str	r1, [r0, #DMC_PHYCONTROL0]

ldr	r1, =0x00101003  @PhyControl0 DLL start
str	r1, [r0, #DMC_PHYCONTROL0]
```

1. `APB_DMC_0_BASE = 0xF000_0000`

   APB 是时钟

2. `DMC_PHYCONTROL0`  物理控制寄存器0

   | PHYCONTROL0      | Bit     | 说明                                                         | 初始值 |
   | ---------------- | ------- | ------------------------------------------------------------ | ------ |
   | ctrl_inc         | [23:16] | DLL延迟增量，增加起点数量<br/>此值应为0x10                   | 0x0    |
   | ctrl_start_point | [15:8]  | DLL锁定起始点<br/>初始DLL锁的起始点。这是延时单元的数量，是 "DLL "开始跟踪锁定的起始点。计算初始延迟时间，用延迟单元格的单位延迟与此值相乘来计算初始延迟时间。<br/>这个值应该是0x10 | 0x0    |
   | ctrl_dll_on      | [1]     | 打开DLL<br/>激活DLL的启动信号。该信号应保持高电平，以便正常工作。如果此信号变低，则DLL关闭，并且`ctrl_clock`和 `ctrl_flock` 变高。此位应在`ctrl_start`设置为打开DLL之前设置 | 0x0    |
   | ctrl_start       | [0]     | 启动 DLL<br/>启动DLL运行和锁定的信号。在正常运行期间，该信号应保持高电平。如果此信号变低，DLL将停止运行。要重新运行DLL，请将此信号再次调高。在重新运行的情况下，DLL会丢失以前的锁信息。在设置 `ctrl_start` 之前，请确保 `ctrl_dll_on`处于高位。 | 0x0    |

3. `DMC_PHYCONTROL1`  物理控制寄存器1

   | PHYCONTROL1 | Bit   | 说明                                                         | 初始值 |
   | ----------- | ----- | ------------------------------------------------------------ | ------ |
   | ctrl_ref    | [7:4] | DLL锁定确认的引用计数                                        | 0x4    |
   | ctrl_shiftc | [2:0] | DQS清洗的相位延迟，0x6 = T/2 (180' shift)<br />根据内存类型的建议值：<br />0x5 when LPDDR/LPDDR2 @200MHz<br/>**0x6 when DDR2 @200MHz** | 0x0    |

### 确定DMC的状态

```js
find_lock_val:
	ldr	r1, [r0, #DMC_PHYSTATUS]  @Load Phystatus register value
	and	r2, r1, #0x7
	cmp	r2, #0x7  @Loop until DLL is locked
	bne	find_lock_val
```

1. `DMC_PHYSTATUS = 0xF000_0040`

2. 寄存器功能

   ![DMC的物理状态](/assets/images/posts/2020-05-22-uboot.startS/phystatus.png)

3. 查看低3位，直到锁定

### 强制锁定

```js
and	r1, #0x3fc0 
mov	r2, r1, LSL #18 r2 = 0xFF0000
orr	r2, r2, #0x100000
orr	r2 ,r2, #0x1000	

orr	r1, r2, #0x3  @Force Value locking
str	r1, [r0, #DMC_PHYCONTROL0]
```

1. 第一部分 `r2 = 0xFF101003`

2. 结果就是把 `ctrl_force = 0xFF`

   | PHYCONTROL0      | Bit     | 说明                                                         | 初始值 |
   | ---------------- | ------- | ------------------------------------------------------------ | ------ |
   | ctrl_force       | [31:24] | DLL强制延迟<br/>当`ctrl_DLL_on`低时，使用此字段代替PHY DLL中的 `ctrl_lock_val[9:2]`。（即，如果DLL关闭，则此字段用于生成270'时钟，并将dq偏移90'） | 0x0    |
   | ctrl_inc         | [23:16] | DLL延迟增量，增加起点数量 此值应为0x10                       | 0x0    |
   | ctrl_start_point | [15:8]  | DLL锁定起始点 初始DLL锁的起始点。这是延时单元的数量，是 "DLL "开始跟踪锁定的起始点。计算初始延迟时间，用延迟单元格的单位延迟与此值相乘来计算初始延迟时间。 这个值应该是0x10 | 0x0    |
   | ctrl_dll_on      | [1]     | 打开DLL 激活DLL的启动信号。该信号应保持高电平，以便正常工作。如果此信号变低，则DLL关闭，并且`ctrl_clock`和 `ctrl_flock` 变高。此位应在`ctrl_start`设置为打开DLL之前设置 | 0x0    |
   | ctrl_start       | [0]     | 启动 DLL 启动DLL运行和锁定的信号。在正常运行期间，该信号应保持高电平。如果此信号变低，DLL将停止运行。要重新运行DLL，请将此信号再次调高。在重新运行的情况下，DLL会丢失以前的锁信息。在设置 `ctrl_start` 之前，请确保 `ctrl_dll_on`处于高位。 | 0x0    |

### 配置 DMC 的控制寄存器

```js
ldr	r0, =APB_DMC_1_BASE

ldr	r1, =0x0FFF2010	 @auto refresh off
str	r1, [r0, #DMC_CONCONTROL]
```

内存控制器的控制寄存器 ，`DMC_CONCONTROL = 0x0FFF2010`

| CONCONTROL  | Bit     | 说明                                                         | 设置值 |
| ----------- | ------- | ------------------------------------------------------------ | ------ |
| timeout_cnt | [27:16] | 默认超时周期<br/>0xn = n个ACLK周期 (ACLK: AXI时钟)<br/>这个计数器可以防止命令队列中的事务被饿死。如果一个新的AXI事务进入队列中，该计数器就会启动。如果计数器变为零，相应的事务将成为命令队列中所有事务中的最高优先级命令。这是一个默认的超时计数器，如果与QoS ID匹配的ARID/AWID进入命令队列，则被QoS计数器覆盖。 | 0xFFF  |
| rd_fetch    | [15:12] | 读取数据获取周期<br/>0xn = n个mclk周期 (mclk: 内存时钟)<br/>该寄存器是针对由tDQSCK变化或板卡飞行时间造成的来自存储器设备的读取数据的不可预测的延迟。PHY读FIFO的读取延迟必须由该参数控制。控制器将在(read_latency + n)mclk循环后从PHY读取数据。 | 0x2    |
| chip1_empty | [9]     | 芯片1的命令队列状态：0x0=不为空；0x1=空<br/>在命令队列条目中没有与chip1内存对应的AXI事务 | 0x0    |
| chip0_empty | [8]     | 不为空                                                       | 0x0    |
| aref_en     | [5]     | 自动刷新计数器：0x0=禁用；0x1=启用<br/>启用此项可在mclk上升沿将自动刷新计数器减少1 | 0x0    |
| out_of      | [4]     | 无序调度：0x0=禁用；0x1=启用<br/>嵌入式调度器支持无序操作以提高SDRAM的利用率<br />Out of Order Scheduling | 0x1    |
| Reserved    | [3:0]   | Should be zero                                               | 0x0    |

### 配置内存控制器 MEMCONTROL

```js
/* MemControl BL=4, 2 chip, DDR2 type, 
 * dynamic self refresh, force precharge, 
 * dynamic power down off */
ldr	r1, =DMC1_MEMCONTROL @ 0x00202400			
str	r1, [r0, #DMC_MEMCONTROL]
```

| MEMCONTROL   | Bit     | 说明                                                         | 设置值 |
| ------------ | ------- | ------------------------------------------------------------ | ------ |
| Reserved     | [31:23] | Should be zero                                               | 0x0    |
| bl           | [22:20] | 内存突发长度，0x2 = 4                                        | 0x2    |
| num_chip     | [19:16] | 存储芯片数量，0x0 = 1 片                                     | 0x0    |
| mem_width    | [15:12] | 存储器数据总线宽度，0x2 = 32-bit                             | 0x2    |
| mem_type     | [11:8]  | 存储器类型，0x4 = DDR2                                       | 0x4    |
| add_lat_pall | [7:6]   | PALL的附加潜伏期，0x0 = 0 cycle<br />如果发出所有芯片bank预充电命令，预充电的延迟将为`tRP + add_lat_pall` | 0x0    |
| dsref_en     | [5]     | 动态自刷新，0x0 = 禁用                                       | 0x0    |
| tp_en        | [4]     | 预充超时，Timeout Precharge，0x0 = 禁用<br />如果启用了 `tp_en`，它会在打开页面策略中的指定mclk周期（如果在周期之间没有进行任何访问）之后自动为打开的芯片预充电。<br/><br/>如果预配置位字段`PrechConfig.tp_cnt`被设置，它指定等待直到超时预充电对开放组预充电的mclk循环量 | 0x0    |
| dpwrdn_type  | [3:2]   | 动态断电类型：<br />0x0=激活/预充电电源关闭<br/>0x1=强制预充电断电 | 0x0    |
| dpwrdn_en    | [1]     | 动态断电Dynamic Power Down，0x0=禁用                         | 0x0    |
| clk_stop_en  | [0]     | 动态时钟控制：0x0 = 总是运行；0x1=空闲期间停止               | 0x0    |

### 设置内存配置器0/1 MEMCONFIG0/1

```js
/* MemConfig0 512MB config, 8 banks,Mapping 
 * Method[12:15]0:linear, 1:linterleaved, 2:Mixed */
ldr	r1, =DMC1_MEMCONFIG_0 @ 0x40F01313		
str	r1, [r0, #DMC_MEMCONFIG0]
ldr	r1, =DMC1_MEMCONFIG_1 @ 0x00F01313
str	r1, [r0, #DMC_MEMCONFIG1]
```

| MEMCONFIG0/1 | Bit     | 说明                                                         | 设置值 |
| ------------ | ------- | ------------------------------------------------------------ | ------ |
| chip_base    | [31:24] | AXI基址[31:24]=芯片基址<br/>例如，如果 `chip_base=0x20`，那么存储芯片0的 AXI base address变为 `0x2000_0000` | 0x40   |
| chip_mask    | [23:16] | AXI基址掩码<br/>用于确定内存芯片0的AXI偏移地址的上地址位掩码。<br/>1 = 屏蔽对应位<br />`chip_mask = 0xF8`，那么偏移地址为 `0x0000_0000 ~ 0x07FF_FFFF` | 0xF0   |
| chip_map     | [15:12] | 地址映射方法（AXI到内存）<br />0x1 = Interleaved ({row, bank, column, width}) | 0x1    |
| chip_col     | [11:8]  | 列地址位数，0x3 = 10 bits                                    | 0x3    |
| chip_row     | [7:4]   | 行地址位数，0x1 = 13 bits                                    | 0x1    |
| chip_bank    | [3:0]   | bank 块数量，0x3 = 8 banks                                   | 0x3    |

### 预充电策略配置寄存器

```js
ldr	r1, =0xFF000000
str	r1, [r0, #DMC_PRECHCONFIG]
```

| PRECHCONFIG  | Bit     | 说明                                                         | 设置值 |
| ------------ | ------- | ------------------------------------------------------------ | ------ |
| tp_cnt       | [31:24] | 预充电循环超时周期<br />0xn = n mclk cycles                  | 0xFF   |
| chip1_policy | [15:8]  | 存储芯片1预充电组选择策略：0x0=打开页策略<br />打开页策略：读或写之后，前面访问的行保持打开状态。<br />关闭页面（自动预充电）策略：在读或写命令之后，内存设备会自动为bank预充电。 | 0x0    |
| chip0_policy | [7:0]   | 存储芯片0预充电组选择策略：0x0=打开页策略                    | 0x1    |

### 设置 TimingAref

```js
/* TimingAref 7.8us*133MHz=1038(0x40E), 100MHz=780(0x30C), 
 * 20MHz=156(0x9C), 10MHz=78(0x4) */
ldr	r1, =DMC1_TIMINGA_REF @ 0x40E			
str	r1, [r0, #DMC_TIMINGAREF]
```

TimingAref：自动刷新存储器的交流定时寄存器

| PRECHCONFIG | Bit     | 说明                                                         | 设置值 |
| ----------- | ------- | ------------------------------------------------------------ | ------ |
| Reserved    | [31:16] | Should be zero                                               | 0x0    |
| t_refi      | [15:0]  | 平均定期刷新间隔<br />应为最小存储器 `tREFI (all bank) < t_refi * T(mclk)`，例如，对于7.8us的全列刷新周期和133MHz的mclk频率，应编程以下值：`7.8 us * 133 MHz = 1038` | 0x40E  |

### 设置 TimingRow

TimingRow：存储器行的交流定时寄存器

```js
ldr	r1, =DMC1_TIMING_ROW @ 0x10233206
str	r1, [r0, #DMC_TIMINGROW]
ldr	r1, =DMC1_TIMING_DATA @TimingData CL=3
str	r1, [r0, #DMC_TIMINGDATA]
ldr	r1, =DMC1_TIMING_PWR @TimingPower
str	r1, [r0, #DMC_TIMINGPOWER]
```

设置各种延时参数		

### 设置存储器直接指令寄存器 DirectCmd

向 DDR2 发送指令，初始化 DDR2 芯片

```js
ldr	r1, =0x07000000	 @DirectCmd	chip0 Deselect
str	r1, [r0, #DMC_DIRECTCMD]
ldr	r1, =0x01000000 @DirectCmd chip0 PALL
str	r1, [r0, #DMC_DIRECTCMD]
# 省略 ........
```

剩下的就是按照 S5PV210 数据手册 P598 DDR2内存类型的初始化序列进行，其中有27步。这里不再分析。

### 配置 PwrdnConfig

```js
ldr	r1, =0xFFFF00FF @PwrdnConfig
str	r1, [r0, #DMC_PWRDNCONFIG]

# 再重新设置，至此 DMC1 完成
ldr	r1, =0x00202400
str	r1, [r0, #DMC_MEMCONTROL]
```

PwrdnConfig：动态掉电配置寄存器

| PWRDNCONFIG | Bit     | 说明                                       | 设置值 |
| ----------- | ------- | ------------------------------------------ | ------ |
| dsref_cyc   | [31:16] | 动态自刷新条目的周期数：0xn  n个 aclk 周期 | 0xFFFF |
| Reserved    | [15:8]  | Should be zero                             | 0x0    |
| dpwrdn_cyc  | [7:0]   | 动态断电条目的周期数：0xn = n aclk cycles  | 0xFF   |

## uart_asm_init 初始化分析

### 设置 GPIO

```js
/* set GPIO(GPA) to enable UART */
@ GPIO setting for UART
ldr	r0, =ELFIN_GPIO_BASE @ 0xE020_0000
ldr	r1, =0x22222222
str   	r1, [r0, #GPA0CON_OFFSET]

ldr     r1, =0x2222
str     r1, [r0, #GPA1CON_OFFSET]
```

1. 核心板原理图

   从核心板原理图可以看到，用于 UART 的是 GPA0[0:7] 管脚

   ![UART管脚](/assets/images/posts/2020-05-22-uboot.startS/uart.png)

2. S5PV210 数据手册

   1. GPA0CON

      | GPA0CON    | Bit     | 说明               | 设置值 |
      | ---------- | ------- | ------------------ | ------ |
      | GPA0CON[7] | [31:28] | 0010 = UART_1_RTSn | 0x2    |
      | GPA0CON[6] | [27:24] | 0010 = UART_1_CTSn | 0x2    |
      | GPA0CON[5] | [23:20] | 0010 = UART_1_TXD  | 0x2    |
      | GPA0CON[4] | [19:16] | 0010 = UART_1_RXD  | 0x2    |
      | GPA0CON[3] | [15:12] | 0010 = UART_0_RTSn | 0x2    |
      | GPA0CON[2] | [11:8]  | 0010 = UART_0_CTSn | 0x2    |
      | GPA0CON[1] | [7:4]   | 0010 = UART_0_TXD  | 0x2    |
      | GPA0CON[0] | [3:0]   | 0010 = UART_0_RXD  | 0x2    |

   2. GPA1CON

      | GPA0CON    | Bit     | 说明              | 设置值 |
      | ---------- | ------- | ----------------- | ------ |
      | GPA1CON[3] | [15:12] | 0010 = UART_3_TXD | 0x2    |
      | GPA1CON[2] | [11:8]  | 0010 = UART_3_RXD | 0x2    |
      | GPA1CON[1] | [7:4]   | 0010 = UART_2_TXD | 0x2    |
      | GPA1CON[0] | [3:0]   | 0010 = UART_2_RXD | 0x2    |

### 设置 UART 参数

```js
ldr	r0, =ELFIN_UART_CONSOLE_BASE @ 0xE290_0800
mov	r1, #0x0
str	r1, [r0, #UFCON_OFFSET] @ 关闭 FIFO
str	r1, [r0, #UMCON_OFFSET] @ 禁用 AFC

mov	r1, #0x3 @ 无奇偶校验；1停止位；8 bit 内容
str	r1, [r0, #ULCON_OFFSET]

ldr	r1, =0x3c5
str	r1, [r0, #UCON_OFFSET]

ldr	r1, =UART_UBRDIV_VAL @ 设置波特率115200
str	r1, [r0, #UBRDIV_OFFSET]

ldr	r1, =UART_UDIVSLOT_VAL
str	r1, [r0, #UDIVSLOT_OFFSET]

ldr	r1, =0x4f4f4f4f
str	r1, [r0, #UTXH_OFFSET] @通过串口2发送'O'

mov	pc, lr
```

1. V210 使用的是 UART3 口

2. 关闭 UFCON 即 UART 的 FIFO 属性

   | UFCONn                | Bit     | 说明                                                         | 设置值 |
   | --------------------- | ------- | ------------------------------------------------------------ | ------ |
   | Reserved              | [31:11] | Reserved                                                     | 0x0    |
   | Tx FIFO Trigger Level | [10:8]  | 决定Tx FIFO的触发电平。如果Tx FIFO的数据量小于或等于触发电平，则发生Tx中断。000 = 0 byte | 0x0    |
   | Reserved              | [7]     | Reserved                                                     | 0x0    |
   | Rx FIFO Trigger Level | [6:4]   | 决定Rx FIFO的触发电平。如果Rx FIFO的数据数大于或等于触发电平，则发生Rx中断。<br />[通道0] 000 = 32 byte；[通道1] 000 = 8 byte<br />[通道2\3] 000 = 2 byte | 0x0    |
   | FIFO Enable           | [0]     | 0 = Disables                                                 | 0x0    |

3. 设置 UMCON 即 UART 的 Modem

   | UMCONn                  | Bit    | 说明                                                         | 设置值 |
   | ----------------------- | ------ | ------------------------------------------------------------ | ------ |
   | Reserved                | [31:8] | Reserved                                                     | 0x0    |
   | RTS trigger Level       | [7:5]  | 决定Rx FIFO的触发电平，以控制nRTS信号。如果AFC位被启用，且Rx FIFO的字节数大于或等于触发电平，nRTS信号被停用。<br />000 = 255 bytes | 0x0    |
   | Auto Flow Control (AFC) | [4]    | 0 = Disables                                                 | 0x0    |
   | Modem Interrupt Enable  | [3]    | 0 = Disables                                                 | 0x0    |
   | Request to Send         | [0]    | 如果AFC位已启用，则该值将被忽略。在这种情况下，S5PV210会自动控制nRTS信号。<br/>如果AFC位被禁用，软件必须控制nRTS信号。 | 0x0    |

4. 设置 ULCON 即 UART line 控制器

   | ULCONn             | Bit    | 说明                                                         | 设置值 |
   | ------------------ | ------ | ------------------------------------------------------------ | ------ |
   | Reserved           | [31:7] | Reserved                                                     | 0x0    |
   | Infrared Mode      | [6]    | 0 = 普通模式；1 = 红外模式                                   | 0x0    |
   | Parity Mode        | [5:3]  | 0xx = 无奇偶校验<br/>100=奇数奇偶数<br/>101=偶数平价<br/>110=强制奇偶校验/检查为1<br/>111 = 强制奇偶校验/检查为0 | 0x0    |
   | Number of Stop Bit | [2]    | 0 = 1位停止位；1 = 2位停止位                                 | 0x0    |
   | Word Length        | [1:0]  | 11 = 8-bit                                                   | 0x11   |

5. 设置 UCON 即 UART 控制寄存器

   | UCONn                            | Bit     | 说明                                                         | 设置值 |
   | -------------------------------- | ------- | ------------------------------------------------------------ | ------ |
   | Reserved                         | [31:21] | Reserved                                                     | 0x0    |
   | Clock Selection                  | [10]    | 0 = PCLK                                                     | 0      |
   | Tx Interrupt Type                | [9]     | 1=电平;0 = 脉冲                                              | 1      |
   | Rx Interrupt Type                | [8]     | 1=电平（当Rx缓冲器在非FIFO模式下接收数据或当它在FIFO模式下达到Rx FIFO触发电平时，请求中断。） | 1      |
   | Rx Time Out Enable               | [7]     | 如果启用UART FIFO，则启用/禁用Rx超时中断。中断是一个接收中断。 | 1      |
   | Rx Error Status Interrupt Enable | [6]     | 在接收操作过程中，当出现异常时，如中断、帧错误、奇偶校验错误或超限错误等异常时，使UART能够产生中断。<br />1 = 生成接收错误状态中断 | 1      |
   | Loop-back Mode                   | [5]     | 将环回位设置为1会触发UART进入环回模式。此模式仅用于测试目的。 | 0      |
   | Send Break Signal                | [4]     | 设置此位会触发UART在1帧时间内发送一个break(中断)。在发送break(中断)信号后，该位会自动清除。<br />0 = 正常发送；1 = 发送 break 信号 | 0      |
   | Transmit Mode                    | [3:2]   | 确定哪个函数能够将Tx数据写入UART发送缓冲寄存器<br />01 = 中断请求或轮询模式 | 01     |
   | Receive Mode                     | [1:0]   | 确定哪个功能能够从UART接收缓冲区寄存器中读取数据。<br />01 = 中断请求或轮询模式 | 01     |

6. 设置 UART 的波特率

   | UBRDIVn  | Bit     | 说明       | 设置值 |
   | -------- | ------- | ---------- | ------ |
   | Reserved | [31:16] | Reserved   | 0      |
   | UBRDIVn  | [15:0]  | 波特率分值 | 0x2    |

   - UART波特率配置
     - UART块中有4个UART波特率除法寄存器，分别是UBRDIV0、UBRDIV1、UBRDIV2和UBRDIV3。
     - 存储在波特率除法器寄存器(UBRDIVn)和除法槽寄存器(UDIVSLOTn)中的值，用于确定串行Tx/Rx时钟速率(波特率)，具体如下：
       - `DIV_VAL = (PCLK / (bps x 16)) − 1`
       - (UDIVSLOTn 数值中1的个数)/16 = `DIV_VAL` 的余数
     - 举例：如果波特率为115200 bps，PCLK 为40 MHz
       - `DIV_VAL = (40000000 / (115200 x 16)) -1 = [20.7] = 20`
       - (UDIVSLOTn 数值中1的个数) / 16 = 0.7
         - `UDIVSLOTn = 16'b1110_1110_1110_1010` 或者
         - `UDIVSLOTn = 16’b0111_0111_0111_0101`
   - 这里设置
     - `UBRDIV2 = 34, UDIVSLOT2 = 0xDDDD`
     - PCLK = 66 MHz，那么 `DIV_VAL = 66000000 / (115200 x 16) - 1 = 34.8，取整数部分为 34
     - 查表 P880 可知 0xDDDD(1101_1101_1101_1101b)对应12个1，12 / 16 = 0.75 = 0.8
