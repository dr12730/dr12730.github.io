I"fy<h1 id="1-训练-faster-rcnn">1 训练 faster RCNN</h1>

<p>Faster rcnn 的 <code class="highlighter-rouge">train_val.py</code> 程序的主干如下，它主要是负责对 <code class="highlighter-rouge">fasterRCNN</code> 网络进行训练：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. 解析参数
</span><span class="n">args</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">()</span>
<span class="c1"># 2. 通过voc整合多个训练集数据
</span><span class="n">imdb</span><span class="p">,</span> <span class="n">roidb</span><span class="p">,</span> <span class="n">ratio_list</span><span class="p">,</span> <span class="n">ratio_index</span> <span class="o">=</span> <span class="n">combined_roidb</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">imdb_name</span><span class="p">)</span>
<span class="c1"># 3. 数据加载器
</span><span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>                            										<span class="n">sampler</span><span class="o">=</span><span class="n">sampler_batch</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">num_workers</span><span class="p">)</span>
<span class="c1"># 4. 构建faster rcnn网络
</span><span class="n">fasterRCNN</span> <span class="o">=</span> <span class="n">resnet</span><span class="p">(</span><span class="n">imdb</span><span class="o">.</span><span class="n">classes</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">class_agnostic</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">class_agnostic</span><span class="p">)</span>
<span class="c1"># 5. 训练rcnn网络
</span><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">start_epoch</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">max_epochs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="c1"># 5.1 将faster rcnn网络的head部分冻结
</span>    <span class="n">fasterRCNN</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    <span class="c1"># 5.2 衰减学习率
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">lr_decay_step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">adjust_learning_rate</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">lr_decay_gamma</span><span class="p">)</span>
        <span class="n">lr</span> <span class="o">*=</span> <span class="n">args</span><span class="o">.</span><span class="n">lr_decay_gamma</span>
    <span class="c1"># 5.3 批训练网络    
</span>   	<span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">dataloaer</span><span class="p">:</span>
        <span class="c1"># 5.3.1 批训练数据
</span>        <span class="n">im_data</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">im_info</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">gt_boxes</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">num_boxes</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">())</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        
        <span class="n">fasterRCNN</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="c1"># 5.3.2 用faster rcnn预估对象类别和边界框
</span>        <span class="n">rois</span><span class="p">,</span> <span class="n">cls_prob</span><span class="p">,</span> <span class="n">bbox_pred</span><span class="p">,</span> \
      	<span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_box</span><span class="p">,</span> \
      	<span class="n">RCNN_loss_cls</span><span class="p">,</span> <span class="n">RCNN_loss_bbox</span><span class="p">,</span> \
      	<span class="n">rois_label</span> <span class="o">=</span> <span class="n">fasterRCNN</span><span class="p">(</span><span class="n">im_data</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
        <span class="c1"># 5.3.3 计算损失
</span>        <span class="n">loss</span> <span class="o">=</span> <span class="n">rpn_loss_cls</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">rpn_loss_box</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> \
           	<span class="o">+</span> <span class="n">RCNN_loss_cls</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span> <span class="n">RCNN_loss_bbox</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="c1"># 5.3.4 反向传播，调整faster rcnn网络     
</span>        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</code></pre></div></div>

<p>误差函数的计算</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># _fasterRCNN.forward()得到
# rcnn 的分类误差
</span><span class="n">RCNN_loss_cls</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">cls_score</span><span class="p">,</span> <span class="n">rois_label</span><span class="p">)</span>
<span class="c1"># rcnn 的回归误差
</span><span class="n">RCNN_loss_bbox</span> <span class="o">=</span> <span class="n">_smooth_l1_loss</span><span class="p">(</span><span class="n">bbox_pred</span><span class="p">,</span> <span class="n">rois_target</span><span class="p">,</span> 
                                 <span class="n">rois_inside_ws</span><span class="p">,</span> <span class="n">rois_outside_ws</span><span class="p">)</span>

<span class="c1"># 在 _fasterRCNN.forward()中，有：
</span><span class="n">rois</span><span class="p">,</span> <span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_bbox</span> 
	<span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_rpn</span><span class="p">(</span><span class="n">base_feat</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
<span class="c1"># self.RCNN_rpn = _RPN(self.dout_base_model)
</span>
<span class="c1"># _RPN.forward()得到
# rpn 的分类误差
</span><span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_cls</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">rpn_cls_score</span><span class="p">,</span> <span class="n">rpn_label</span><span class="p">)</span>
<span class="c1"># 计算rpn的边界误差，请注意在这里用到了inside和outside_weights
</span><span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_box</span> <span class="o">=</span> <span class="n">_smooth_l1_loss</span><span class="p">(</span><span class="n">rpn_bbox_pred</span><span class="p">,</span> <span class="n">rpn_bbox_targets</span><span class="p">,</span> 
                                    <span class="n">rpn_bbox_inside_weights</span><span class="p">,</span>
                                    <span class="n">rpn_bbox_outside_weights</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</code></pre></div></div>

<h1 id="2-通过voc整合多个训练集数据">2 通过voc整合多个训练集数据</h1>

<p>首先 <code class="highlighter-rouge">combined_roidb</code> 函数的架构如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">combined_roidb</span><span class="p">(</span><span class="n">imdb_names</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">roidbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_roidb</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">imdb_names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'+'</span><span class="p">)]</span>
  	<span class="n">roidb</span> <span class="o">=</span> <span class="n">roidbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># len(roidb) = 1002
</span>  	
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roidb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># 如果roidbs多于1个，则进行roidb融合, 本例len(roidbs) = 1
</span>        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 通过名字得到imdb
</span>		<span class="n">imdb</span> <span class="o">=</span> <span class="n">get_imdb</span><span class="p">(</span><span class="n">imdb_names</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">training</span><span class="p">:</span>
        <span class="c1"># 过滤掉没有前景的roidb
</span>        <span class="n">roidb</span> <span class="o">=</span> <span class="n">filter_roidb</span><span class="p">(</span><span class="n">roidb</span><span class="p">)</span>
        
    <span class="c1"># 根据宽高比对roidb进行从低到高的排序
</span>    <span class="n">ratio_list</span><span class="p">,</span> <span class="n">ratio_index</span> <span class="o">=</span> <span class="n">rank_roidb_ratio</span><span class="p">(</span><span class="n">roidb</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">imdb</span><span class="p">,</span> <span class="n">roidb</span><span class="p">,</span> <span class="n">ratio_list</span><span class="p">,</span> <span class="n">ratio_index</span>
</code></pre></div></div>

<h3 id="21-get_roidbs-的解析">2.1 get_roidb(s) 的解析</h3>

<p><code class="highlighter-rouge">imdb_names</code> 来自入参 <code class="highlighter-rouge">args.imdb_name = voc_2007_trainval</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_roidb</span><span class="p">(</span><span class="n">imdb_name</span><span class="p">):</span>
    <span class="c1"># 从 voc 中获取图像数据库信息
</span>    <span class="n">imdb</span> <span class="o">=</span> <span class="n">get_imdb</span><span class="p">(</span><span class="n">imdb_name</span><span class="p">)</span>

    <span class="c1"># 设置proposal方法，这里是gt（config.py）
</span>    <span class="n">imdb</span><span class="o">.</span><span class="n">set_proposal_method</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">TRAIN</span><span class="o">.</span><span class="n">PROPOSAL_METHOD</span><span class="p">)</span>

    <span class="c1"># 得到用于训练的roidb
</span>    <span class="c1"># 从imdb中抽取roidb，并给roidb加入一些属性：
</span>    <span class="c1"># 所属图像的id，图像路径，图像的(w, h)，
</span>    <span class="c1"># 每幅图中每个roi与真实框的重大重合度值 roidb['max_overlaps']
</span>    <span class="c1"># 每幅图中每个roi的最大真实重合框所属的类别 roidb['max_classes']
</span>    <span class="n">roidb</span> <span class="o">=</span> <span class="n">get_training_roidb</span><span class="p">(</span><span class="n">imdb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">roidb</span>
</code></pre></div></div>

<p>这里的 <code class="highlighter-rouge">get_imdb(imdb_names)</code> 是返回一个voc实例：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_imdb</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">__sets</span><span class="p">[</span><span class="n">name</span><span class="p">]()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">imdb</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">datasets</span><span class="o">.</span><span class="n">pascal_voc</span><span class="o">.</span><span class="n">pascal_voc</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f60e737d860</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">get_training_roidb</span><span class="p">(</span><span class="n">imdb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">TRAIN</span><span class="o">.</span><span class="n">USE_FLIPPED</span><span class="p">:</span>
      <span class="n">imdb</span><span class="o">.</span><span class="n">append_flipped_images</span><span class="p">()</span> <span class="c1"># 在imdb类中，实现水平翻转
</span>    <span class="n">prepare_roidb</span><span class="p">(</span><span class="n">imdb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">imdb</span><span class="o">.</span><span class="n">roidb</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">prepare_roidb</span><span class="p">(</span><span class="n">imdb</span><span class="p">):</span>
    <span class="s">'''
    计算出 roidb 的一些常用属性
    '''</span>
    <span class="n">roidb</span> <span class="o">=</span> <span class="n">imdb</span><span class="o">.</span><span class="n">roidb</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Image</span><span class="o">.</span><span class="nb">open</span><span class="p">(</span><span class="n">imdb</span><span class="o">.</span><span class="n">image_path_at</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imdb</span><span class="o">.</span><span class="n">num_images</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imdb</span><span class="o">.</span><span class="n">image_index</span><span class="p">)):</span>
        <span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'img_id'</span><span class="p">]</span> <span class="o">=</span> <span class="n">imdb</span><span class="o">.</span><span class="n">image_id_at</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'image'</span><span class="p">]</span> <span class="o">=</span> <span class="n">imdb</span><span class="o">.</span><span class="n">image_path_at</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">imdb</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'coco'</span><span class="p">)):</span>
            <span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'width'</span><span class="p">]</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'height'</span><span class="p">]</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># roidb[i]：第i幅图像的所有roi，roidb[i]['gt']roi与第i类别gt的重合度
</span>        <span class="c1"># gt_overlaps 维度是 [roi_box_num, class_num]
</span>        <span class="n">gt_overlaps</span> <span class="o">=</span> <span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'gt_overlaps'</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">max_overlaps</span> <span class="o">=</span> <span class="n">gt_overlaps</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 第i幅图每个roi与真实框的最大重合度
</span>        <span class="n">max_classes</span> <span class="o">=</span> <span class="n">gt_overlaps</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 第i幅图每个roi最大重合度所属的类别
</span>    	<span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'max_classes'</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_classes</span> <span class="c1"># 每个roi最大真实框所属的类别
</span>    	<span class="n">roidb</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">'max_overlaps'</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_overlaps</span> <span class="c1"># 第i图每个roi与真实框的最大重合度
</span></code></pre></div></div>

<h1 id="3-冻结部分resnet网络">3 冻结部分resnet网络</h1>

<p>因为只需要训练部分resnet网络，所以要对网络的head部分进行冻结</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">resnet</span><span class="p">(</span><span class="n">_fasterRCNN</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    	<span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_base</span><span class="o">.</span><span class="nb">eval</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_base</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_base</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_base</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">set_bn_eval</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_top</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">set_bn_eval</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_bn_eval</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">classname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">if</span> <span class="n">classname</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">'BatchNorm'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">m</span><span class="o">.</span><span class="nb">eval</span><span class="p">()</span> 
</code></pre></div></div>

<h2 id="4-faster-rcnn-的训练">4 faster rcnn 的训练</h2>

<p>接下来是最复杂的faster rcnn 部分，用faster rcnn预估对象类别和边界框</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rois</span><span class="p">,</span> <span class="n">cls_prob</span><span class="p">,</span> <span class="n">bbox_pred</span><span class="p">,</span> \
<span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_box</span><span class="p">,</span> \
<span class="n">RCNN_loss_cls</span><span class="p">,</span> <span class="n">RCNN_loss_bbox</span><span class="p">,</span> \
<span class="n">rois_label</span> <span class="o">=</span> <span class="n">fasterRCNN</span><span class="p">(</span><span class="n">im_data</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">resnet</span><span class="p">(</span><span class="n">_fasterRCNN</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">num_layers</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">class_agnostic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_path</span> <span class="o">=</span> <span class="s">'data/pretrained_model/resnet101_caffe.pth'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dout_base_model</span> <span class="o">=</span> <span class="mi">1024</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pretrained</span> <span class="o">=</span> <span class="n">pretrained</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_agnostic</span> <span class="o">=</span> <span class="n">class_agnostic</span>

        <span class="n">_fasterRCNN</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">class_agnostic</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_head_to_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool5</span><span class="p">):</span>
        <span class="n">fc7</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_top</span><span class="p">(</span><span class="n">pool5</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fc7</span>
</code></pre></div></div>

<p>下面重要的是 <code class="highlighter-rouge">_fasterRCNN</code> 类，其初始化如下，主要是定义了 <code class="highlighter-rouge">rpn</code> 网络和 <code class="highlighter-rouge">roi pool</code> 层</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">_fasterRCNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">class_agnostic</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_fasterRCNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">classes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_agnostic</span> <span class="o">=</span> <span class="n">class_agnostic</span>
        <span class="c1"># loss
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_loss_cls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_loss_bbox</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 定义 rpn 网络
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_rpn</span> <span class="o">=</span> <span class="n">_RPN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dout_base_model</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_proposal_target</span> <span class="o">=</span> <span class="n">_ProposalTargetLayer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_classes</span><span class="p">)</span>
		<span class="c1"># 定义 roi pool 层
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_roi_pool</span> <span class="o">=</span> <span class="n">ROIPool</span><span class="p">((</span><span class="n">cfg</span><span class="o">.</span><span class="n">POOLING_SIZE</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">POOLING_SIZE</span><span class="p">),</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">16.0</span><span class="p">)</span>
</code></pre></div></div>

<p>最重要的是它的 <code class="highlighter-rouge">forward</code> 函数，大致架构如下（省去了部分细节）：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class _fasterRCNN(nn.Module):
</span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_data</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">):</span> 
    <span class="c1"># 将图像数据馈送到基础模型以获得基础特征图，RCNN_base是在resnet类的_init_modules中定义的
</span>    <span class="c1"># self.RCNN_base = nn.Sequential(resnet.conv1, resnet.bn1,resnet.relu,
</span>    <span class="c1">#  				resnet.maxpool,resnet.layer1,resnet.layer2,resnet.layer3)
</span>    <span class="n">base_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_base</span><span class="p">(</span><span class="n">im_data</span><span class="p">)</span>

    <span class="c1"># 基础特征图送到 RPN 得到 ROIS
</span>    <span class="n">rois</span><span class="p">,</span> <span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_bbox</span> 
    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_rpn</span><span class="p">(</span><span class="n">base_feat</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>

    <span class="c1"># 如果是在训练 用ground truth回归
</span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
        <span class="n">roi_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_proposal_target</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
        <span class="n">rois</span><span class="p">,</span> <span class="n">rois_label</span><span class="p">,</span> <span class="n">rois_target</span><span class="p">,</span> <span class="n">rois_inside_ws</span><span class="p">,</span> <span class="n">rois_outside_ws</span> <span class="o">=</span> <span class="n">roi_data</span>

        <span class="n">rois_label</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rois_label</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">long</span><span class="p">())</span>
        <span class="n">rois_target</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rois_target</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rois_target</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">rois_inside_ws</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rois_inside_ws</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rois_inside_ws</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">rois_outside_ws</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rois_outside_ws</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rois_outside_ws</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>

    <span class="n">rois</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rois</span><span class="p">)</span>
    <span class="c1"># 利用ROI pooling从基础特征图中提取候选特征图 proposal feature
</span>    <span class="n">pooled_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_roi_pool</span><span class="p">(</span><span class="n">base_feat</span><span class="p">,</span> <span class="n">rois</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>

    <span class="c1"># pooling后的候选特征图到top模块
</span>    <span class="c1"># self.RCNN_top = nn.Sequential(resnet.layer4) 与layer1相同，也是卷积操作
</span>    <span class="c1"># fc7 = self.RCNN_top(pool5).mean(3).mean(2)
</span>    <span class="n">pooled_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_to_tail</span><span class="p">(</span><span class="n">pooled_feat</span><span class="p">)</span>

    <span class="c1"># 计算bounding box的偏移 self.RCNN_bbox_pred = nn.Linear(2048, 4)
</span>    <span class="n">bbox_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_bbox_pred</span><span class="p">(</span><span class="n">pooled_feat</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_agnostic</span><span class="p">:</span>
        <span class="c1"># 根据roi标签选择相应的列
</span>        <span class="n">bbox_pred_view</span> <span class="o">=</span> <span class="n">bbox_pred</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bbox_pred</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">bbox_pred</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">bbox_pred_select</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">bbox_pred_view</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> \
                                        <span class="n">rois_label</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">rois_label</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>\
                                        <span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">rois_label</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">bbox_pred</span> <span class="o">=</span> <span class="n">bbox_pred_select</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">bbox_pred</span> <span class="o">=</span> <span class="n">bbox_pred</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">rois</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 计算对象分类概率 self.RCNN_cls_score = nn.Linear(2048, self.n_classes)
</span>    <span class="n">cls_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_cls_score</span><span class="p">(</span><span class="n">pooled_feat</span><span class="p">)</span>
    <span class="n">cls_prob</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">cls_score</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cls_prob</span> <span class="o">=</span> <span class="n">cls_prob</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">rois</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
        <span class="c1"># 分类损失
</span>        <span class="n">RCNN_loss_cls</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">cls_score</span><span class="p">,</span> <span class="n">rois_label</span><span class="p">)</span>
        <span class="c1"># 回归损失
</span>        <span class="n">RCNN_loss_bbox</span> <span class="o">=</span> <span class="n">_smooth_l1_loss</span><span class="p">(</span><span class="n">bbox_pred</span><span class="p">,</span> <span class="n">rois_target</span><span class="p">,</span> 
                                         <span class="n">rois_inside_ws</span><span class="p">,</span> <span class="n">rois_outside_ws</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rois</span><span class="p">,</span> <span class="n">cls_prob</span><span class="p">,</span> <span class="n">bbox_pred</span><span class="p">,</span> <span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_bbox</span><span class="p">,</span> <span class="n">RCNN_loss_cls</span><span class="p">,</span> <span class="n">RCNN_loss_bbox</span><span class="p">,</span> <span class="n">rois_label</span>

</code></pre></div></div>

<p>由上可以知道，<code class="highlighter-rouge">fast rcnn</code> 的训练分成如下几步：</p>

<ol>
  <li>
    <p>由 <code class="highlighter-rouge">resnet</code> 网络得到基础特征图</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">base_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_base</span><span class="p">(</span><span class="n">im_data</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>基础特征图送到 RPN 得到 ROIS</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rois</span><span class="p">,</span> <span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_bbox</span> 
<span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_rpn</span><span class="p">(</span><span class="n">base_feat</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>对 rois 进行精简处理</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">roi_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_proposal_target</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
<span class="n">rois</span><span class="p">,</span> <span class="n">rois_label</span><span class="p">,</span> <span class="n">rois_target</span><span class="p">,</span> <span class="n">rois_inside_ws</span><span class="p">,</span> <span class="n">rois_outside_ws</span> <span class="o">=</span> <span class="n">roi_data</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>利用 ROI Pooling 方法，从基础特征图中选取 ROI 部分的池化图</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pooled_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_roi_pool</span><span class="p">(</span><span class="n">base_feat</span><span class="p">,</span> <span class="n">rois</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>将池化后的候选池化图送入top网络，获得候选区域特征图</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># self.RCNN_top = nn.Sequential(resnet.layer4)
# fc7 = self.RCNN_top(pool5).mean(3).mean(2)
</span><span class="n">pooled_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_to_tail</span><span class="p">(</span><span class="n">pooled_feat</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>利用候选区域特征图预估候选框的偏移</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bbox_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_bbox_pred</span><span class="p">(</span><span class="n">pooled_feat</span><span class="p">)</span>
<span class="c1"># self.RCNN_bbox_pred = nn.Linear(2048, 4)
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>利用候选区域特征图预估物体类别</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cls_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_cls_score</span><span class="p">(</span><span class="n">pooled_feat</span><span class="p">)</span>
<span class="n">cls_prob</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">cls_score</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># self.RCNN_cls_score = nn.Linear(2048, self.n_classes)
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>计算分类误差和回归误差</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RCNN_loss_cls</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">cls_score</span><span class="p">,</span> <span class="n">rois_label</span><span class="p">)</span>
<span class="n">RCNN_loss_bbox</span> <span class="o">=</span> <span class="n">_smooth_l1_loss</span><span class="p">(</span><span class="n">bbox_pred</span><span class="p">,</span> <span class="n">rois_target</span><span class="p">,</span> 
                                 <span class="n">rois_inside_ws</span><span class="p">,</span> <span class="n">rois_outside_ws</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>我们继续追进去，看看具体细节的实现</p>

<h4 id="基础特征图送到-rpn-得到-rois-是如何实现的">基础特征图送到 RPN 得到 ROIS 是如何实现的？</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rois</span><span class="p">,</span> <span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="n">rpn_loss_bbox</span> 
<span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RCNN_rpn</span><span class="p">(</span><span class="n">base_feat</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">)</span>
<span class="c1"># self.RCNN_rpn = _RPN(self.dout_base_model)
</span></code></pre></div></div>

<h5 id="rpn的初始化大体架构">RPN的初始化，大体架构：</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">_RPN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">din</span><span class="p">):</span>
        <span class="c1">#得到输入特征图的深度
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">din</span> <span class="o">=</span> <span class="n">din</span> 
        <span class="c1">#anchor的等级 __C.ANCHOR_SCALES = [8,16,32]
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">anchor_scales</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">ANCHOR_SCALES</span> 
        <span class="c1">#anchor的宽高比 __C.ANCHOR_RATIOS = [0.5,1,2]
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">anchor_ratios</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">ANCHOR_RATIOS</span> 
        <span class="c1">#特征步长 __C.FEAT_STRIDE = [16, ]
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">feat_stride</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">FEAT_STRIDE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 定义处理输入特征图的convrelu层
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">RPN_Conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">din</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># 通过 RPN_Conv生成的512特征，分别用于分类和回归
</span>
        <span class="c1"># 定义背景和前景分类得分层 nc: nclass  2(bg/fg) * 9 (anchors)
</span>        <span class="c1"># 前景／背景的类别得分， 网络输入是512 输出是参数个数nc
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">nc_score_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_scales</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_ratios</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RPN_cls_score</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_score_out</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 定义anchor的偏移预测层，回归到边界框  4(coords) * 9 (anchors)
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">nc_bbox_out</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_scales</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor_ratios</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RPN_bbox_pred</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_bbox_out</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 定义anchor目标层 _AnchorTargetLayer, 产生分类的真值rpn_labels
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">RPN_anchor_target</span> <span class="o">=</span> <span class="n">_AnchorTargetLayer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feat_stride</span><span class="p">,</span> 
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">anchor_scales</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_ratios</span><span class="p">)</span>        
        
        <span class="c1"># 定义候选区域层 _ProposalLayer, 参数：特征步长、等级、比例
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">RPN_proposal</span> <span class="o">=</span> <span class="n">_ProposalLayer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feat_stride</span><span class="p">,</span> 
                                           <span class="bp">self</span><span class="o">.</span><span class="n">anchor_scales</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor_ratios</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_cls</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_box</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>这里出现了几个关键层：<code class="highlighter-rouge">_ProposalLayer</code> 候选区域层和 <code class="highlighter-rouge">_AnchorTargetLayer</code> 锚框目标层，让我们来看看它们是什么</p>

<ol>
  <li>锚框目标层 _AnchorTargetLayer</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">_AnchorTargetLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="s">"""
    利用gtbox，将固定锚框生成锚框目标，作为候选区域网络的拟合目标：(类别，框坐标)
    1. 先要在原始图上均匀的划分出AxHxW个 anchors（A=9，H是feature map的高度，W是宽度）
    2. 删除不在图像中的 anchors
    3. 将与gtbox有最大IoU的anchor标记为前景
    4. IoU &gt; 0.7 的anchor标记为前景，label = 1
    5. IoU &lt; 0.3的标记为背景: label=0
    6. 计算从anchors变到gtbox要修正的变化量，记为 bbox_targets
    7. 只有前景类内部权重才非0，参与回归
    8. 外部权重初始化 bbox_outside_weights[labels == 1] = positive_weights
    9. 将label立体化为特征图的长宽，这样每个label对应特征图的一个像素, 也就是给每一个anchor都打上前景或背景的label。
    有了labels，你就可以对RPN进行训练使它对任意输入都具备识别前景、背景的能力

    返回值：
        outputs = [labels, bbox_targets, bbox_inside_weights, bbox_outside_weights]
        labels：特征图上每个点的标签，背景或前景
        bbox_targets：特征图对应的anchor要变成真实的gt boxes的改变量(dx, dy, dw, dh)
        bbox_weights：权值
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feat_stride</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">ratios</span><span class="p">):</span>
        <span class="c1"># 省略部分代码
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_anchors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
            <span class="c1"># 以(0, 0, 15, 15)为基础生成9个框(0.5, 1, 2)宽高比 * (8, 16, 32)等级
</span>            <span class="n">generate_anchors</span><span class="p">(</span><span class="n">scales</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">anchor_scales</span><span class="p">),</span> 	
                             <span class="n">ratios</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratios</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="nb">float</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
      <span class="s">"""
      省略
      """</span>
</code></pre></div></div>

<ol>
  <li>候选区域层 ProposalLayer</li>
</ol>

<p>是对 <code class="highlighter-rouge">input</code> 中的所有17100个锚框目标进行精简，根据这17100个框的类别概率大小进行删减，再通过MNS删减，从而得到最好的锚框</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">_ProposalLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feat_stride</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">ratios</span><span class="p">):</span> <span class="c1"># 参数： 特征步长 等级 比例
</span>        <span class="nb">super</span><span class="p">(</span><span class="n">_ProposalLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c1"># 得到特征步长
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_feat_stride</span> <span class="o">=</span> <span class="n">feat_stride</span>
        <span class="c1"># 以(0,0, 15,15)窗口为基础，生成9个锚框，它们也是以(左上角，右下角)的格式排列成行
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_anchors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">generate_anchors</span><span class="p">(</span><span class="n">scales</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scales</span><span class="p">),</span>
            <span class="n">ratios</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratios</span><span class="p">)))</span><span class="o">.</span><span class="nb">float</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_anchors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchors</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="s">'''
        1. 通过 feature_stride * H * W 复制self._anchors生成anchors
        2. anchors变动bbox_deltas，变成候选框(proposals)
        3. 移除四个角不在图像边界内的候选框
        4. 对分数(概率)从大到小进行排序
        5. 在NMS之前接受最高的 pre_nms_topN 个提议区
        6. 将门槛为0.7的NMS应用于剩余提议
        7. 在NMS之后接受 after_nms_topN 候选框
        8. return 顶级候选框
        
        input = (rpn_cls_prob.data, rpn_bbox_pred.data, im_info, cfg_key)
        output = (batch_no, proposals)  第1列为batch号，后面为候选框坐标
        '''</span>
        <span class="c1"># 前景概率
</span>        <span class="n">scores</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_anchors</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># 偏移 17100 偏移
</span>        <span class="n">bbox_deltas</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 图像信息 (h, w, scale)
</span>        <span class="n">im_info</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># 是training还是test
</span>        <span class="n">cfg_key</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<h5 id="rpn-的前向传播">RPN 的前向传播</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_feat</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">):</span>
    <span class="c1">#features信息包括 (batch_size，data_height，data_width，num_channels)
</span>    <span class="c1">#即批尺寸，特征数据高度，特征数据宽度，特征的通道数。
</span>    <span class="n">batch_size</span> <span class="o">=</span> <span class="n">base_feat</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1"># 1. 对resnet抓取的基础特征进行分析，得到分类概率
</span>    <span class="n">rpn_conv1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RPN_Conv</span><span class="p">(</span><span class="n">base_feat</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="n">rpn_cls_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RPN_cls_score</span><span class="p">(</span><span class="n">rpn_conv1</span><span class="p">)</span> <span class="c1"># 得到RPN分类得分
</span>    <span class="n">rpn_cls_score_reshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rpn_cls_score</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># 2 - 前景/背景
</span>    <span class="c1"># 用softmax函数得到前景和背景概率
</span>    <span class="n">rpn_cls_prob_reshape</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">rpn_cls_score_reshape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 前景背景分类，2个参数 nc_score_out = 2(bg/fg) * 9 (anchors)
</span>    <span class="n">rpn_cls_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rpn_cls_prob_reshape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nc_score_out</span><span class="p">)</span>

    <span class="c1"># 2. 利用基础特征预估边界框偏移
</span>    <span class="n">rpn_bbox_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RPN_bbox_pred</span><span class="p">(</span><span class="n">rpn_conv1</span><span class="p">)</span>

    <span class="n">cfg_key</span> <span class="o">=</span> <span class="s">'TRAIN'</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="k">else</span> <span class="s">'TEST'</span>
    <span class="c1"># 提取候选区域  self.RPN_proposal = _ProposalLayer(input) 
</span>    <span class="c1"># 对input中的所有17100个锚框目标按概率大小和NMS方案进行精简
</span>    <span class="c1"># 其实 RPN_proposal 应该叫 RPN_proposal_reduce
</span>    <span class="n">rois</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RPN_proposal</span><span class="p">((</span><span class="n">rpn_cls_prob</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rpn_bbox_pred</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                              <span class="n">im_info</span><span class="p">,</span> <span class="n">cfg_key</span><span class="p">))</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_cls</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_box</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 生成训练标签并构建rpn损失
</span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
        <span class="c1"># self.RPN_anchor_target = _AnchorTargetLayer()
</span>        <span class="c1"># 利用gtbox，将固定锚框变成锚框目标(类别，框坐标)，作为候选区域网络的拟合对象
</span>        <span class="c1"># 其实 anchor_target 应该叫 proposal_target
</span>        <span class="n">rpn_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RPN_anchor_target</span><span class="p">((</span><span class="n">rpn_cls_score</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">im_info</span><span class="p">,</span> <span class="n">num_boxes</span><span class="p">))</span>

        <span class="c1"># 计算分类损失
</span>        <span class="c1"># 返回rpn网络判断的anchor前后景分数
</span>        <span class="n">rpn_cls_score</span> <span class="o">=</span> <span class="n">rpn_cls_score_reshape</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>\
        <span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># 返回每个anchor属于前景还是后景的ground truth
</span>        <span class="n">rpn_label</span> <span class="o">=</span> <span class="n">rpn_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># rpn_keep = rpn_label中不为-1的索引，-1是要忽略的标签
</span>        <span class="n">rpn_keep</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rpn_label</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># 返回得分中前景和背景的得分和label
</span>        <span class="n">rpn_cls_score</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">rpn_cls_score</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rpn_keep</span><span class="p">)</span>
        <span class="n">rpn_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">rpn_label</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rpn_keep</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">rpn_label</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rpn_label</span><span class="o">.</span><span class="nb">long</span><span class="p">())</span>
        <span class="c1"># 计算rpn的分类误差
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_cls</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="n">rpn_cls_score</span><span class="p">,</span> <span class="n">rpn_label</span><span class="p">)</span>
        <span class="c1"># 统计前景数目
</span>        <span class="n">fg_cnt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">rpn_label</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        
        <span class="c1"># 计算回归损失        
</span>        <span class="n">rpn_bbox_targets</span><span class="p">,</span> <span class="n">rpn_bbox_inside_weights</span><span class="p">,</span> <span class="n">rpn_bbox_outside_weights</span> <span class="o">=</span> <span class="n">rpn_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># 在训练计算边框误差时有用，仅对未超出图像边界的anchor有用
</span>        <span class="n">rpn_bbox_inside_weights</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rpn_bbox_inside_weights</span><span class="p">)</span>
        <span class="n">rpn_bbox_outside_weights</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rpn_bbox_outside_weights</span><span class="p">)</span>
        <span class="n">rpn_bbox_targets</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">rpn_bbox_targets</span><span class="p">)</span>

        <span class="c1"># 计算rpn的边界误差，请注意在这里用到了inside和outside_weights
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_box</span> <span class="o">=</span> <span class="n">_smooth_l1_loss</span><span class="p">(</span><span class="n">rpn_bbox_pred</span><span class="p">,</span> <span class="n">rpn_bbox_targets</span><span class="p">,</span> 
                                            <span class="n">rpn_bbox_inside_weights</span><span class="p">,</span>
                                            <span class="n">rpn_bbox_outside_weights</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">rois</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpn_loss_box</span>
</code></pre></div></div>

<p>这样就得到了faster训练所需的rpn误差值</p>

<h2 id="附录">附录</h2>

<h3 id="_smooth_l1_loss">_smooth_l1_loss</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_smooth_l1_loss</span><span class="p">(</span><span class="n">bbox_pred</span><span class="p">,</span> <span class="n">bbox_targets</span><span class="p">,</span> <span class="n">bbox_inside_weights</span><span class="p">,</span> 
                    <span class="n">bbox_outside_weights</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>

    <span class="n">sigma_2</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">box_diff</span> <span class="o">=</span> <span class="n">bbox_pred</span> <span class="o">-</span> <span class="n">bbox_targets</span>
    <span class="n">in_box_diff</span> <span class="o">=</span> <span class="n">bbox_inside_weights</span> <span class="o">*</span> <span class="n">box_diff</span>
    <span class="n">abs_in_box_diff</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">in_box_diff</span><span class="p">)</span>
    <span class="n">smoothL1_sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">abs_in_box_diff</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">sigma_2</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="nb">float</span><span class="p">()</span>
    <span class="n">in_loss_box</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="nb">pow</span><span class="p">(</span><span class="n">in_box_diff</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma_2</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="n">smoothL1_sign</span> \
                  <span class="o">+</span> <span class="p">(</span><span class="n">abs_in_box_diff</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">sigma_2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">smoothL1_sign</span><span class="p">)</span>
    <span class="n">out_loss_box</span> <span class="o">=</span> <span class="n">bbox_outside_weights</span> <span class="o">*</span> <span class="n">in_loss_box</span>
    <span class="n">loss_box</span> <span class="o">=</span> <span class="n">out_loss_box</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
      <span class="n">loss_box</span> <span class="o">=</span> <span class="n">loss_box</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">loss_box</span> <span class="o">=</span> <span class="n">loss_box</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">loss_box</span>
</code></pre></div></div>

<h3 id="resnetlayer4">resnet.layer4</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">layer4</span><span class="p">):</span> <span class="n">Sequential</span><span class="p">(</span>
      <span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="n">Bottleneck</span><span class="p">(</span>
        <span class="p">(</span><span class="n">conv1</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn1</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">conv2</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
                        <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn2</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">conv3</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn3</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">relu</span><span class="p">):</span> <span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="p">(</span><span class="n">downsample</span><span class="p">):</span> <span class="n">Sequential</span><span class="p">(</span>
          <span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
          <span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">)</span>
      <span class="p">)</span>
      <span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="n">Bottleneck</span><span class="p">(</span>
        <span class="p">(</span><span class="n">conv1</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn1</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">conv2</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> 
                        <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn2</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">conv3</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn3</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">relu</span><span class="p">):</span> <span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
      <span class="p">)</span>
      <span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="n">Bottleneck</span><span class="p">(</span>
        <span class="p">(</span><span class="n">conv1</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn1</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
                           <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">conv2</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                        <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn2</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> 
                           <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">conv3</span><span class="p">):</span> <span class="n">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="p">(</span><span class="n">bn3</span><span class="p">):</span> <span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">affine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> 
                           <span class="n">track_running_stats</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="p">(</span><span class="n">relu</span><span class="p">):</span> <span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></div>
:ET